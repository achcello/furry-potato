#pragma config(Sensor, dgtl1,  encLiftRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encLiftLeft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encClawRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  encClawLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  encDriveRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, encDriveLeft,    sensorQuadEncoder)
#pragma config(Motor,  port1,           clawLeft,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           lift3,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           lift2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           left,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           right,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lift4,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          clawRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//for Margaret Thatcher, the robot

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include <Vex_Competition_Includes.c>

#define CLenc encClawLeft
#define CRenc encClawRight
#define DFLenc encDriveLeft
#define DFRenc encDriveRight
#define Aenc ( ( abs(SensorValue[encLiftRight]) + abs(SensorValue[encLiftLeft]) ) / 2 )
#define CR clawRight
#define CL clawLeft
#define DL driveLeft
#define DR driveRight

#define getQuadVal() ( ( abs(SensorValue[encLiftRight]) + abs(SensorValue[encLiftLeft]) ) / 2 )

enum Dir
{
  FORWARD,
  BACKWARD,
  LEFT,
  RIGHT,
  CW,
  CCW
};

/*
* Distance
* Measurement
* Definitions
*/
/////////////////////////////////////////////////         CONSTANTS         ////////////////////////////////////////////
// Wheel Diameter
const float WHEEL_DIAMETER = 4.0;

// Base Dimentions, Center of Wheel to Center of Wheel
// Please Update when the Wheel Spacing Changes
// Distance Left to Right
const float BASE_X_DIST = 14.75;
// Distance Front to Back
const float BASE_Y_DIST = 12.625;

const short DRIVE_TURN_LIMIT = 110;

//number of iteration pid continues after setpoint is reached
//this is necessary because it may overshoot/oscilate slightly
//control needs time to stabalize
const int DRIVE_EXTRA_IT = 5;
const int DRIVE_CLOSE_ENOUGH = 10;

/*
* Power
* Limit
* Definitions
*/

// Drive
// Speed Motor Limit: Current Value
// Torque Motor Limit: 127
const float DRIVE_POWER_LIMIT = 127*0.8;


/////////////////////////////////////////////////         Non-Constants         ////////////////////////////////////////////

static float driveSetPointR;// inches
static float driveSetPointL;// inches

bool isDriveDone = true;

short autonDrivePower = 0;

bool clawPIDRunning = true;
bool pressedLastCycle = false;
bool lock = false;

float clawSetPoint = 0;

/*
* Value Limitation
* Function
*/

void drive(int rot1, int trans1)
{
  motor[port4] = 0.8*(trans1 + rot1);
  motor[port5] = 0.8*(trans1 - rot1);
}

void lift(int liftPower)
{
  motor[lift2] = liftPower;
  motor[lift1] = liftPower;
  motor[lift3] = liftPower;
  motor[lift4] = liftPower;
}

// Used to Limit Power and Target Settings
// Input the Original Value, Upper Limit, and Lower Limit
float limit(float &input, float limitUpper, float limitLower)
{
  if (input > limitUpper) input = limitUpper;
  if (input < limitLower) input = limitLower;
  return input;
}

short limit(short &input, short limitUpper, short limitLower)
{
  if (input > limitUpper) input = limitUpper;
  if (input < limitLower) input = limitLower;
  return input;
}

/*
* PID
* Function
*/

// Main PID Function Called Throughout the Code
// Please See Included Documentation of the PID Function for Explanation of Inputs, and PID itself
const float INTEGRAL_ACTIVE_ZONE = 50.0;
// derivative must oppose motion
float pid(float kp, float ki, float kd, float target, float &error, float &errorTotal, float &prevError, float sensVal)
{
  error = target - sensVal;
  errorTotal += error;
  float deltaError = error - prevError;

  //set components of pid
  float proportional = kp * error;
  float integral = ki * errorTotal;
  float derivative = kd * deltaError;

  // Prevent Integral from Getting Too High or Too Low
  if (integral > INTEGRAL_ACTIVE_ZONE) {
    integral = INTEGRAL_ACTIVE_ZONE;
  }
  if (integral < -INTEGRAL_ACTIVE_ZONE) {
    integral = -INTEGRAL_ACTIVE_ZONE;
  }

  prevError = error;

  return (proportional + integral + derivative);
}

float getTicks(float in)
{
  return 360.0*(in/(PI*WHEEL_DIAMETER));//627.2
}

void encDriveClear()
{
  SensorValue[encDriveRight] = 0;
  SensorValue[encDriveLeft] = 0;
}

void encLiftClear()
{
  SensorValue[encLiftRight] = 0;
  SensorValue[encLiftLeft] = 0;
}

void encClawClear()
{
  SensorValue[encClawRight] = 0;
  SensorValue[encClawLeft] = 0;
}

void pre_auton()
{
  encDriveClear();
  encLiftClear();
  encClawClear();
}

task drivePID()
{

  static float drive_auton_kp = 0.266;
  static float drive_auton_ki = 0.0000013;
  static float drive_auton_kd = 60.0;

  static float turn_auton_kp = 0.842;
  static float turn_auton_ki = 0.00000001;
  static float turn_auton_kd = 27.0;

  static float L_drive_error = 0;
  float L_drive_prevError = 0;
  float L_drive_errorTotal = 0;

  static float R_drive_error = 0;
  float R_drive_prevError = 0;
  float R_drive_errorTotal = 0;

  long time0 = time1[T1] - 20;
  long dt = 0;

  static float L_drive_sensVal, R_drive_sensVal;

  float motorLDriveAutonOutput, motorRDriveAutonOutput;

  encDriveClear();

  isDriveDone = true;
  int itDriveSetReached = 0;
  bool ctrStarted = false;

  while (true)
  {
    if(!isDriveDone) {
      float kp, ki, kd;
      //if turning
      if((driveSetPointL > 0 && driveSetPointR < 0) || (driveSetPointL < 0 && driveSetPointR > 0)) {
        kp = turn_auton_kp;
        ki = turn_auton_ki;
        kd = turn_auton_kd;
      }
      //if driving straight
      else
      {
        kp = drive_auton_kp;
        ki = drive_auton_ki;
        kd = drive_auton_kd;
      }



      dt = time1[T1] - time0;
      time0 = time1[T1];

      L_drive_sensVal = SensorValue[DFLenc];
      R_drive_sensVal = SensorValue[DFRenc];

      motorLDriveAutonOutput = pid(kp, ki, kd, driveSetPointL, L_drive_error, L_drive_errorTotal, L_drive_prevError, L_drive_sensVal);
      motorRDriveAutonOutput = pid(kp, ki, kd, driveSetPointR, R_drive_error, R_drive_errorTotal, R_drive_prevError, R_drive_sensVal);

      limit(motorLDriveAutonOutput, DRIVE_POWER_LIMIT, -DRIVE_POWER_LIMIT);
      limit(motorRDriveAutonOutput, DRIVE_POWER_LIMIT, -DRIVE_POWER_LIMIT);

      motor[DL] = motorLDriveAutonOutput;
      motor[DR] = motorRDriveAutonOutput;

      if(!ctrStarted && abs(motorLDriveAutonOutput) < DRIVE_CLOSE_ENOUGH  && abs(motorRDriveAutonOutput) < DRIVE_CLOSE_ENOUGH) {
        ctrStarted = true;
      }
      if(ctrStarted) itDriveSetReached++;

      if(itDriveSetReached > DRIVE_EXTRA_IT) {
        isDriveDone = true;
        ctrStarted = false;
        itDriveSetReached = 0;
      }
    }
    wait1Msec(20);
  }
}

task pincerPID()
{
  const float L_claw_kp = 6.75;
  const float L_claw_ki = 0.0075;
  const float L_claw_kd = 0.375;

  const float R_claw_kp = 6.75;
  const float R_claw_ki = 0.0075;
  const float R_claw_kd = 0.375;

  float L_claw_error = 0;
  float L_claw_prevError = 0;
  float L_claw_errorTotal = 0;

  float R_claw_error = 0;
  float R_claw_prevError = 0;
  float R_claw_errorTotal = 0;

  float L_claw_sensVal, R_claw_sensVal;

  while (true)
  {
    if(clawPIDRunning)
    {
      L_claw_sensVal = SensorValue(encClawLeft);
      R_claw_sensVal = SensorValue(encClawRight);

      motor[CL] = pid(L_claw_kp, L_claw_ki, L_claw_kd, clawSetPoint, L_claw_error, L_claw_errorTotal, L_claw_prevError, L_claw_sensVal);
      motor[CR] = pid(R_claw_kp, R_claw_ki, R_claw_kd, clawSetPoint, R_claw_error, R_claw_errorTotal, R_claw_prevError, R_claw_sensVal);
    }
    sleep(20);
  }
}

void WaitUntilDriveDone() {
  int t0 = time1[T1];
  //only allow 4 seconds max
  while(!isDriveDone && time1[T1] - t0 < 4000) {
    sleep(20); // wait until drive finishes
  }
}

void setDriveSetPoint(float setPoint, Dir dir)
{
  switch(dir)
  {
  case FORWARD:
    driveSetPointR = getTicks(setPoint);
    driveSetPointL = driveSetPointR;
    break;

  case BACKWARD:
    driveSetPointR = -getTicks(setPoint);
    driveSetPointL = driveSetPointR;
    break;

  case CW:
    driveSetPointR = -getTicks( (setPoint/360.0)*PI*sqrt(pow(BASE_X_DIST, 2.0) + pow(BASE_Y_DIST, 2.0)) );
    driveSetPointL = -driveSetPointR;
    break;

  case CCW:
    driveSetPointR = getTicks( (setPoint/360.0)*PI*sqrt(pow(BASE_X_DIST, 2.0) + pow(BASE_Y_DIST, 2.0)) );
    driveSetPointL = -driveSetPointR;
    break;

  case LEFT:
    // Placeholder for Possible Future H-Drive Implementation
    break;

  case RIGHT:
    // Placeholder for Possible Future H-Drive Implementation
    break;
  }
  clearDBenc();
  isDriveDone = false;
  WaitUntilDriveDone();
  motor[DL] = 0;
  motor[DR] = 0;
}

task updatePincerUserControl()
{
  int CLsens, CRsens;
  int lastTime = 0;
  int CLAW_MIN_ROTATION = 100000000;
  int CLAW_MAX_ROTATION = -100000000;
  while(true)
  {
    CLsens = SensorValue(CLenc);
    CRsens = SensorValue(CRenc);

    if (vexRT[Btn8R] == 1 || vexRT[Btn8DXmtr2] == 1) {
      clawPIDRunning = false;
      // to give other thread time,  stop pid
      sleep(30);
      motor[CL] = 0;
      motor[CR] = 0;
      clawSetPoint = (CLsens + CRsens) / 2.0;
      lastTime = time1[T1];
    }
    else {
      if (vexRT[Btn5U] == 1 || vexRT[Btn6UXmtr2] == 1)
      {
        clawPIDRunning = false;
        // open claw fast
        if(CLsens < CLAW_MIN_ROTATION) motor[CL] = 127;
        if(CRsens < CLAW_MIN_ROTATION) motor[CR] = 127;
        clawSetPoint = (CLsens + CRsens) / 2.0;
        lastTime = time1[T1];
        lock = false;
      }
      else if (vexRT[Btn6U] == 1 || vexRT[Btn6DXmtr2] == 1)
      {
        clawPIDRunning = false;
        // close claw fast
        if(CLsens > CLAW_MAX_ROTATION) motor[CL] = -127;
        if(CRsens > CLAW_MAX_ROTATION) motor[CR] = -127;
        clawSetPoint = (CLsens + CRsens) / 2.0;
        lastTime = time1[T1];
        lock = true;
      }
      /*else if (vexRT[Btn6D] == 1 || vexRT[Btn5DXmtr2] == 1)
      {
        clawPIDRunning = false;
        // close claw slow
        if(CLsens > CLAW_MAX_ROTATION) motor[CL] = 30;
        if(CRsens > CLAW_MAX_ROTATION) motor[CR] = 30;
        clawSetPoint = (CLsens + CRsens) / 2.0;
        lastTime = time1[T1];
      }
      else if (vexRT[Btn5D] == 1 || vexRT[Btn5UXmtr2] == 1)
      {
        clawPIDRunning = false;
        // open claw slow
        if(CLsens < CLAW_MIN_ROTATION) motor[CL] = -30;
        if(CRsens < CLAW_MIN_ROTATION) motor[CR] = -30;
        clawSetPoint = (CLsens + CRsens) / 2.0;
        lastTime = time1[T1];
      }*/
      else
      {
        if(time1[T1] - lastTime < 300) {
          clawSetPoint = (CLsens + CRsens) / 2.0;
        }
        if(!lock){
          clawPIDRunning = true;
        }
        else
        {
        motor[CL] = -30;
        motor[CR] = -30;
        }
      }
    }

    sleep(20);
  }
}

task autonomous()
{
  //startTask(timeAuton);
  /*encClawClear();
  encLiftClear();
  encDriveClear();
  startTask(pincerPID);
  //startTask(autoAdjustMotors);
  driveExactly(72);
  clawSetPoint = -160;
  wait1Msec(2000);
  lift(127);
  wait1Msec(2000);
  lift(0);
  driveExactly(-72);
  clawSetPoint = 0;
  wait10Msec(20);
  stopAllTasks();
  /*if(SensorValue[skills] == 1)
    runAutonomousSequenceSkills();
  else
    if(SensorValue[autonomousSide] == 0)
      runAutonomousSequenceRight();
    else
      runAutonomousSequenceLeft();*/
}

task usercontrol()
{
  encClawClear();
  encLiftClear();
  encDriveClear();
  int t1 = 0, r1 = 0, motorThreshold = 25;
  startTask(pincerPID);
  startTask(updatePincerUserControl);

  while(true){
    if(vexRT[Btn7R] == 1)
      startTask(autonomous);

    if(vexRT[Btn7L] == 1)
      stopTask(autonomous);


    if(abs(vexRT[Ch1]) > motorThreshold)
      r1 = vexRT[Ch1];
    else
      r1 = 0;

    if(abs(vexRT[Ch2]) > motorThreshold)
      t1 = vexRT[Ch2];
    else
      t1 = 0;

    if (abs(vexRT[Ch3]) > motorThreshold)
    {
      lift(vexRT[Ch3]);
    }
    else
    {
      lift(0);
    }
    drive(r1,t1);
  }
}
