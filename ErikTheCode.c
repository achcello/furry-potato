#pragma config(Sensor, dgtl1,  encLiftRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encLiftLeft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encClawRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  encClawLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  encDriveRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, encDriveLeft,    sensorQuadEncoder)
#pragma config(Motor,  port1,           clawLeft,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           lift3,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           lift2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           driveRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lift4,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          clawRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define CLenc encClawLeft
#define CRenc encClawRight
#define DFLenc encDriveLeft
#define DFRenc encDriveRight
#define Aenc ( ( abs(SensorValue[encLiftRight]) + abs(SensorValue[encLiftLeft]) ) / 2 )
#define CR clawRight
#define CL clawLeft
#define DL driveLeft
#define DR driveRight


#include <Vex_Competition_Includes.c>
//*!!Code used to configure robot for 'VEX' robotics match                       !!*//

/*
* Developed:
*      For: Edmund Fitzgerald, the robot
*      By: SharkRado Robotics, Team 1965R
*
* Copyright:
*      (c) 2017 SharkRado Robotics
*      Adlai E. Stevenson High School VEX Robotics Team 1965R
*
* PID Documentation:
*      (c) 2017 SharkRado Robotics
*      Explains PID and the PID Function Implementation

*/

/*
* Direction
* Definitions
*/

// Base Movement Directions
enum Dir
{
	FORWARD,
	BACKWARD,
	LEFT,
	RIGHT,
	CW,
	CCW
};

/*
* Distance
* Measurement
* Definitions
*/
/////////////////////////////////////////////////         CONSTANTS         ////////////////////////////////////////////
// Wheel Diameter
const float WHEEL_DIAMETER = 4.0;

// Base Dimentions, Center of Wheel to Center of Wheel
// Please Update when the Wheel Spacing Changes
// Distance Left to Right
const float BASE_X_DIST = 13.25;
// Distance Front to Back
const float BASE_Y_DIST = 12.0;

// Arm Gear Ratio For Encoder (Output/Input)
const float ARM_GEAR_RATIO = 1.0;

// Maximum and Minimum Arm Angle
const float ARM_MAX_ROTATION = 112.5 * ARM_GEAR_RATIO;
const float ARM_MIN_ROTATION = 0 * ARM_GEAR_RATIO;
const float ARM_LOW_FENCE_ANGLE = 64 * ARM_GEAR_RATIO;
const float ARM_HIGH_FENCE_ANGLE = 69 * ARM_GEAR_RATIO;
const float ARM_MID_ANGLE = 48 * ARM_GEAR_RATIO;

// Claw Gear Ratio For Encoder (Output/Input)
const float CLAW_GEAR_RATIO = 1.0;

// Maximum and Mimimun Claw Angle
const float CLAW_MAX_ROTATION = 999 * (CLAW_GEAR_RATIO);
const float CLAW_MIN_ROTATION = -999 * (CLAW_GEAR_RATIO);

const short DRIVE_TURN_LIMIT = 110;

//number of iteration pid continues after setpoint is reached
//this is necessary because it may overshoot/oscilate slightly
//control needs time to stabalize
const int DRIVE_EXTRA_IT = 5;
const int DRIVE_CLOSE_ENOUGH = 10;

/*
* Power
* Limit
* Definitions
*/

// Claw
const float CLAW_POWER_LIMIT = 127;

// Arm
static float ARM_POWER_LIMIT = 127;

// Drive
// Speed Motor Limit: Current Value
// Torque Motor Limit: 127
const float DRIVE_POWER_LIMIT = 127*0.75;

//const float TURN_CONST = 6.0;

/////////////////////////////////////////////////         Non-Constants         ////////////////////////////////////////////

static float armSetPoint; // degrees
static float driveSetPointR; // inches
static float driveSetPointL;// inches
static float clawSetPoint; // degrees

bool clawPIDRunning = true;
bool armPIDRunning = true;
bool isDriveDone = true;

short autonArmPower = 0;
short autonDrivePower = 0;

/*
* Value Limitation
* Function
*/

// Used to Limit Power and Target Settings
// Input the Original Value, Upper Limit, and Lower Limit
float limit(float &input, float limitUpper, float limitLower)
{
	if (input > limitUpper) input = limitUpper;
	if (input < limitLower) input = limitLower;
	return input;
}

short limit(short &input, short limitUpper, short limitLower)
{
	if (input > limitUpper) input = limitUpper;
	if (input < limitLower) input = limitLower;
	return input;
}

/*
* PID
* Function
*/

// Main PID Function Called Throughout the Code
// Please See Included Documentation of the PID Function for Explanation of Inputs, and PID itself
const float INTEGRAL_ACTIVE_ZONE = 25.0;
// derivative must oppose motion
float pid(float kp, float ki, float kd, float target, float &error, float &errorTotal, float &prevError, float sensVal, long dt)
{
	error = target - sensVal;
	errorTotal += error*dt;
	float rateError = (error - prevError)/(float)(dt);

	float proportional = kp * error;
	float integral = ki * errorTotal;
	float derivative = kd * rateError;
	//if error and derivative are the same sign
	if( (derivative > 0 && error > 0) || (derivative < 0 && error < 0) )
	{
			derivative = 0;
	}
	// Limit Integral to the Integral Active Zone
	limit(integral, INTEGRAL_ACTIVE_ZONE, -INTEGRAL_ACTIVE_ZONE);

	prevError = error;

	return proportional + integral + derivative;
}

/*
* Arm
* Motor Power
* Function
*/

// Sets All Arm Motors to Same Power Value
// Input the Desired Motor Power for All Arm Motors
void setArm(float power, int sens)
{
	//if(sens > 110*ARM_GEAR_RATIO) limit(power, ARM_POWER_LIMIT/*/3.0*/, -ARM_POWER_LIMIT);
	//else limit(power, ARM_POWER_LIMIT, -ARM_POWER_LIMIT);
	limit(power, ARM_POWER_LIMIT, -ARM_POWER_LIMIT);

	motor[lift1] = power;
	motor[lift2] = power;
	motor[lift3] = power;
	motor[lift4] = power;
}

/*
* Pre-Autonomous
* Sub-Functions
*/

// Clear Drive Encoders
void clearDBenc()
{
	SensorValue[DFLenc] = 0;
	SensorValue[DFRenc] = 0;
	//nMotorEncoder[DL] = 0;
	//nMotorEncoder[DR] = 0;
}

// Clear Arm Encoders
void clearAenc()
{

	SensorValue[Aenc] = 2 * ARM_GEAR_RATIO;
}

// Clear Claw Encoders
void clearCenc()
{
	SensorValue[CLenc] = 0;
	SensorValue[CRenc] = 0;
}

/*
* Pre-Autonomous
* Function
*/

// Used to Clear Encoder Values Before the Match
void pre_auton()
{
	clearDBenc();
	clearAenc();
	clearCenc();
}

/*
* Autonomous
* Claw
* Function
*/

// Sends Motor Powers to Robot Based on Target for PID
// Input Desured Target for Each Drive Encoder
task clawPID()
{
	const float L_claw_kp = 3.3;
	const float L_claw_ki = 0.0000001;
	const float L_claw_kd = 40.0;

	const float R_claw_kp = 3.3;
	const float R_claw_ki = 0.0000001;
	const float R_claw_kd = 40.0;

	static float L_claw_error = 0;
	float L_claw_prevError = 0;
	float L_claw_errorTotal = 0;

	static float R_claw_error = 0;
	float R_claw_prevError = 0;
	float R_claw_errorTotal = 0;

	static float L_claw_sensVal, R_claw_sensVal;

	long time0 = time1[T1] - 20;
	long dt = 0;

	float motorLClawOutput, motorRClawOutput;
	static float clawTarget;
	while (true)
	{
		if(clawPIDRunning)
		{
			dt = time1[T1] - time0;
			time0 = time1[T1];

			clawTarget = clawSetPoint*CLAW_GEAR_RATIO;
			limit(clawTarget, CLAW_MAX_ROTATION, CLAW_MIN_ROTATION);

			L_claw_sensVal = SensorValue(CLenc);
			R_claw_sensVal = SensorValue(CRenc);

			motorLClawOutput = pid(L_claw_kp, L_claw_ki, L_claw_kd, clawTarget, L_claw_error, L_claw_errorTotal, L_claw_prevError, L_claw_sensVal, dt);
			motorRClawOutput = pid(R_claw_kp, R_claw_ki, R_claw_kd, clawTarget, R_claw_error, R_claw_errorTotal, R_claw_prevError, R_claw_sensVal, dt);

			limit(motorLClawOutput, CLAW_POWER_LIMIT, -CLAW_POWER_LIMIT);
			limit(motorRClawOutput, CLAW_POWER_LIMIT, -CLAW_POWER_LIMIT);

			motor[DLF] = motorLClawOutput;
			motor[DLR] = motorLClawOutput;
			motor[DRF] = motorRClawOutput;
			motor[DRR] = motorLClawOutput;
		}
		sleep(20);
	}
}

/*
* Autonomous
* Arm
* Function
*/

// Used For Arm Adjustment
// Input Desired Degree Target and Power/Speed

task armPID()
{
	static float arm_kp = 4.6;
	static float arm_ki = 0.00001;
	static float arm_kd = 45.0;

	static float arm_error = 0;
	float arm_prevError = 0;
	float arm_errorTotal = 0;

	float arm_sensVal;

	long time0 = time1[T1] - 20;
	long dt = 0;
	float armTarget;

	while (true)
	{
		if(armPIDRunning)
		{
			dt = time1[T1] - time0;
			time0 = time1[T1];

			armTarget = armSetPoint*ARM_GEAR_RATIO;
			limit(armTarget, ARM_MAX_ROTATION, ARM_MIN_ROTATION);

			arm_sensVal = SensorValue[Aenc];

			// PID Output to Arm Limited in The Set Arm Power Function
			setArm(pid(arm_kp, arm_ki, arm_kd, armTarget, arm_error, arm_errorTotal, arm_prevError, arm_sensVal, dt), arm_sensVal);
		}
		sleep(20);
	}
}

task autonArmNormal()
{
	short sens = 0;

	while(true) {
		sens = SensorValue[Aenc];

		if(sens > 100 * ARM_GEAR_RATIO)
		{
			if(autonArmPower < 0) setArm(autonArmPower, sens);
			else setArm(0, sens);
		}
		else if(sens < 0)
		{
			if(autonArmPower > 0) setArm(autonArmPower, sens);
			else setArm(0, sens);
		}
		else
		{
			if(autonArmPower > 0)
			{
				if(sens < 100*ARM_GEAR_RATIO) setArm(autonArmPower, sens);
			}
			else
			{
				limit(autonArmPower, 0, -ARM_POWER_LIMIT / 3);
				setArm(autonArmPower, sens);
			}

		}
	}
}

task autonDriveNormal() {
	while(1) {
		motor[DL] = autonDrivePower;
		motor[DR] = autonDrivePower;
		sleep(20);
	}
}

// Converts Inches to Degree Change for the Drive Wheels
// Input Desired Inch Change
float getTicks(float in)
{
	return 360.0*(in/(PI*WHEEL_DIAMETER));//627.2
}
//*rt2

// Sends Motor Powers to Robot Based on Target for PID
// Input Desired Target for Each Drive Encoder
task drivePID()
{

	static float drive_auton_kp = 0.266;
	static float drive_auton_ki = 0.0000013;
	static float drive_auton_kd = 60.0;

	static float turn_auton_kp = 0.842;
	static float turn_auton_ki = 0.00000001;
	static float turn_auton_kd = 27.0;

	static float L_drive_error = 0;
	float L_drive_prevError = 0;
	float L_drive_errorTotal = 0;

	static float R_drive_error = 0;
	float R_drive_prevError = 0;
	float R_drive_errorTotal = 0;

	long time0 = time1[T1] - 20;
	long dt = 0;

	static float L_drive_sensVal, R_drive_sensVal;

	float motorLDriveAutonOutput, motorRDriveAutonOutput;

	clearDBenc();

	isDriveDone = true;
	int itDriveSetReached = 0;
	bool ctrStarted = false;

	while (true)
	{
		if(!isDriveDone) {
			float kp, ki, kd;
			//if turning
			if((driveSetPointL > 0 && driveSetPointR < 0) || (driveSetPointL < 0 && driveSetPointR > 0)) {
				kp = turn_auton_kp;
				ki = turn_auton_ki;
				kd = turn_auton_kd;
			}
			//if driving straight
			else
			{
				kp = drive_auton_kp;
				ki = drive_auton_ki;
				kd = drive_auton_kd;
			}



			dt = time1[T1] - time0;
			time0 = time1[T1];

			L_drive_sensVal = SensorValue[DFLenc];
			R_drive_sensVal = SensorValue[DFRenc];

			motorLDriveAutonOutput = pid(kp, ki, kd, driveSetPointL, L_drive_error, L_drive_errorTotal, L_drive_prevError, L_drive_sensVal, dt);
			motorRDriveAutonOutput = pid(kp, ki, kd, driveSetPointR, R_drive_error, R_drive_errorTotal, R_drive_prevError, R_drive_sensVal, dt);

			limit(motorLDriveAutonOutput, DRIVE_POWER_LIMIT, -DRIVE_POWER_LIMIT);
			limit(motorRDriveAutonOutput, DRIVE_POWER_LIMIT, -DRIVE_POWER_LIMIT);

			motor[DLF] = motorLDriveAutonOutput;
			motor[DLR] = motorLDriveAutonOutput;
			motor[DRF] = motorRDriveAutonOutput;
			motor[DRR] = motorRDriveAutonOutput;

			if(!ctrStarted && abs(motorLDriveAutonOutput) < DRIVE_CLOSE_ENOUGH  && abs(motorRDriveAutonOutput) < DRIVE_CLOSE_ENOUGH) {
				ctrStarted = true;
			}
			if(ctrStarted) itDriveSetReached++;

			if(itDriveSetReached > DRIVE_EXTRA_IT) {
				isDriveDone = true;
				ctrStarted = false;
				itDriveSetReached = 0;
			}
		}
		wait1Msec(20);
	}
}

void WaitUntilDriveDone() {
	int t0 = time1[T1];
	//only allow 4 seconds max
	while(!isDriveDone && time1[T1] - t0 < 4000) {
		sleep(20); // wait until drive finishes
	}
}


// Used For Basic Motion (Forward/Backward)
// Input Desired Inch/degree Movement, Direction, and Power/Speed
void setDriveSetPoint(float setPoint, Dir dir)
{
	switch(dir)
	{
	case FORWARD:
		driveSetPointR = getTicks(setPoint);
		driveSetPointL = driveSetPointR;
		break;

	case BACKWARD:
		driveSetPointR = -getTicks(setPoint);
		driveSetPointL = driveSetPointR;
		break;

	case CW:
		driveSetPointR = -getTicks( (setPoint/360.0)*PI*sqrt(pow(BASE_X_DIST, 2.0) + pow(BASE_Y_DIST, 2.0)) );
		driveSetPointL = -driveSetPointR;
		break;

	case CCW:
		driveSetPointR = getTicks( (setPoint/360.0)*PI*sqrt(pow(BASE_X_DIST, 2.0) + pow(BASE_Y_DIST, 2.0)) );
		driveSetPointL = -driveSetPointR;
		break;

	case LEFT:
		// Placeholder for Possible Future H-Drive Implementation
		break;

	case RIGHT:
		// Placeholder for Possible Future H-Drive Implementation
		break;
	}
	clearDBenc();
	isDriveDone = false;
	WaitUntilDriveDone();
	motor[DL] = 0;
	motor[DR] = 0;
}


/*
*
* Main
* Autonomous
* Task
*
*/

//grab cube, knock stars off low fence, then right high fence
//start on right side
void auton1() {

	clawSetPoint = -80;
	sleep(500);
	//setDriveSetPoint(12, FORWARD);
	//setDriveSetPoint(12, BACKWARD);
	startTask(autonDriveNormal);
	autonDrivePower = 127;
	sleep(700);
	autonDrivePower = -127;
	sleep(700);
	stopTask(autonDriveNormal);

	setDriveSetPoint(35, FORWARD);
	clawSetPoint = 15;
	sleep(1000);
	armSetPoint = 30;
	sleep(300);
	setDriveSetPoint(90, CCW);

	armPIDRunning = false;
	startTask(autonArmNormal);
	autonArmPower = 20;

	setDriveSetPoint(18, BACKWARD);
	autonArmPower = ARM_POWER_LIMIT;
	sleep(790);
	clawSetPoint = -75;
	autonArmPower = ARM_POWER_LIMIT;
	sleep(710);
	autonArmPower = -30;

	autonArmPower = 0;
	stopTask(autonArmNormal);

	//knock stuff off fence
	setDriveSetPoint(12, FORWARD);
	armPIDRunning = true;
	armSetPoint = ARM_LOW_FENCE_ANGLE;
	setDriveSetPoint(180, CW);
	setDriveSetPoint(20, FORWARD);

	//knock more stuff off fence
	setDriveSetPoint(12, BACKWARD);
	setDriveSetPoint(90, CW);
	setDriveSetPoint(45, FORWARD);
	setDriveSetPoint(90, CCW);
	armSetPoint = ARM_HIGH_FENCE_ANGLE;
	setDriveSetPoint(38, FORWARD);

	setDriveSetPoint(24, BACKWARD);
	armPIDRunning = false;
	setArm(0, SensorValue[Aenc]);

	sleep(1000);


}

// Runs the Autonomous Code During the Autonomous Portion of the Competition
task autonomous()
{
	pre_auton();
	armPIDRunning = true;
	clawPIDRunning = true;

	startTask(clawPID);
	startTask(armPID);
	startTask(drivePID);


	//change clawSetPoint and ArmSetPoint  directly using values in degrees
	//change driveSetPoint by calling setDriveSetpoint()
	//note: setDriveSetPoint() will wait until the previous setpoint has been reached

	// arm and claw don't wait to finish before moving to next command
	// so, to move arm and drive at the same time, set the arm then call the drive function

	auton1();

	//stopAllTasks();
	while(true) {
		sleep(9999999);
	}
}

/*
* User Control
* Claw
* Sub-Task
*/

// Controls the Claw of the Robot During the User Control Portion of the Competition
task updateClawUserControl()
{
	int CLsens, CRsens;

	int lastTime = 0;
	while(true)
	{
		CLsens = SensorValue(CLenc);
		CRsens = SensorValue(CRenc);

		if (vexRT[Btn8R] == 1 || vexRT[Btn8DXmtr2] == 1) {
			clawPIDRunning = false;
			// to give other thread time,  stop pid
			sleep(30);
			motor[CL] = 0;
			motor[CR] = 0;
			clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
			lastTime = time1[T1];
		}
		else {
			if (vexRT[Btn5U] == 1 || vexRT[Btn6UXmtr2] == 1)
			{
				clawPIDRunning = false;
				// open claw fast
				if(CLsens > CLAW_MIN_ROTATION) motor[CL] = -127;
				if(CRsens > CLAW_MIN_ROTATION) motor[CR] = -127;
				clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				lastTime = time1[T1];
			}
			else if (vexRT[Btn6U] == 1 || vexRT[Btn6DXmtr2] == 1)
			{
				clawPIDRunning = false;
				// close claw fast
				if(CLsens < CLAW_MAX_ROTATION) motor[CL] = 127;
				if(CRsens < CLAW_MAX_ROTATION) motor[CR] = 127;
				clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				lastTime = time1[T1];
			}
			else if (vexRT[Btn6D] == 1 || vexRT[Btn5DXmtr2] == 1)
			{
				clawPIDRunning = false;
				// close claw slow
				if(CLsens < CLAW_MAX_ROTATION) motor[CL] = 30;
				if(CRsens < CLAW_MAX_ROTATION) motor[CR] = 30;
				clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				lastTime = time1[T1];
			}
			else if (vexRT[Btn5D] == 1 || vexRT[Btn5UXmtr2] == 1)
			{
				clawPIDRunning = false;
				// open claw slow
				if(CLsens > CLAW_MIN_ROTATION) motor[CL] = -30;
				if(CRsens > CLAW_MIN_ROTATION) motor[CR] = -30;
				clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				lastTime = time1[T1];
			}
			else
			{
				if(time1[T1] - lastTime < 300) {
					clawSetPoint = (CLsens + CRsens) / (2.0 * CLAW_GEAR_RATIO);
				}
				clawPIDRunning = true;
			}
		}

		sleep(20);
	}
}

/*
* User Control
* Arm
* Sub-Task
*/

// Controls the Arm of the Robot Durring the User Control Portion of the Competition
task armUserControl()
{
	armPIDRunning = false;
	startTask(armPID);
	const int armChThreshold = 15;

	float armTarget = SensorValue[Aenc];

	long dt;
	long time0 = time1[T1] - 20;
	long lastTime = time1[T1] - 10000;
	while (true)
	{
		dt = time1[T1] - time0;
		time0 = time1[T1];

		if(abs(vexRT[Ch2]) > armChThreshold) {
			lastTime = time1[T1];
			armTarget = SensorValue[Aenc];
		}

		if ((vexRT[Btn8UXmtr2] == 1) || (vexRT[Btn7L] == 1))
		{
			armPIDRunning = false;
			armTarget = SensorValue[Aenc];
			setArm(0, SensorValue[Aenc]);
		}
		else
		{
			if(vexRT[Btn8D] == 1)
			{
				armPIDRunning = true;
				armTarget = ARM_LOW_FENCE_ANGLE / ARM_GEAR_RATIO;
				armSetPoint = ARM_LOW_FENCE_ANGLE;
			}
			else if(vexRT[Btn8R] == 1 || vexRT[Btn8L] == 1)
			{
				armPIDRunning = true;
				armTarget = ARM_MID_ANGLE / ARM_GEAR_RATIO;
				armSetPoint = ARM_MID_ANGLE;
			}
			else if(vexRT[Btn8U] == 1)
			{
				armPIDRunning = true;
				armTarget = ARM_HIGH_FENCE_ANGLE / ARM_GEAR_RATIO;
				armSetPoint = ARM_HIGH_FENCE_ANGLE;
			}
			else if (SensorValue[Aenc] > ARM_MAX_ROTATION)
			{
				if ((vexRT[Btn7U] == 1 && abs(vexRT[Ch2]) > armChThreshold) || vexRT[Ch2] <= -armChThreshold)
				{
					armPIDRunning = false;
					setArm(vexRT[Ch3], SensorValue[Aenc]);
				}
				else
				{
					armPIDRunning = true;
				}
			}
			else if (SensorValue[Aenc] <= ARM_MIN_ROTATION) {
				if ((vexRT[Btn7U] == 1 && abs(vexRT[Ch2]) > armChThreshold) || vexRT[Ch2] >= armChThreshold)
				{
					armPIDRunning = false;
					setArm(vexRT[Ch3], SensorValue[Aenc]);
				}
				else if(abs(vexRT[Ch3]) > armChThreshold)
				{
					//armPIDRunning = false;
					short s = vexRT[Ch3];
					setArm(limit(s, ARM_POWER_LIMIT, -30), SensorValue[Aenc]);
				}
				else
				{
					//armPIDRunning = true;
				}
			}
			else
			{
				if (abs(vexRT[Ch3]) > armChThreshold)
				{
					//armPIDRunning = false;
					setArm(vexRT[Ch3], SensorValue[Aenc]);
				}
				else
				{
					if(time1[T1] - lastTime < 80)	armTarget = SensorValue[Aenc];
					//armPIDRunning = true;
				}
			}
		}
		armSetPoint = limit(armTarget, ARM_MAX_ROTATION, ARM_MIN_ROTATION) / ARM_GEAR_RATIO;
		sleep(20);
	}
}

/*
* User Control
* Drive
* Sub-Task
*/

// Controls the Drive of the Robot Durring the User Control Portion of the Competition
task driveUserControl ()
{

	float Y1 = 0, X1 = 0;

	const int driveChThreshold = 15;

	float motorLDriveUserOutput, motorRDriveUserOutput;

	while (true)
	{


		if ((abs(vexRT[Ch2]) > driveChThreshold) || (abs(vexRT[Ch1]) > driveChThreshold))
		{
			Y1 = vexRT[Ch2];
			X1 = vexRT[Ch1];
		}
		else
		{
			X1 = 0;
			Y1 = 0;
		}
		limit(X1, DRIVE_TURN_LIMIT, -DRIVE_TURN_LIMIT);

		motorLDriveUserOutput = Y1 + X1;
		motorRDriveUserOutput = Y1 - X1;


		limit(motorLDriveUserOutput, DRIVE_POWER_LIMIT, -DRIVE_POWER_LIMIT);
		limit(motorRDriveUserOutput, DRIVE_POWER_LIMIT, -DRIVE_POWER_LIMIT);

		motor[DL] = motorLDriveUserOutput;
		motor[DR] = motorRDriveUserOutput;


		wait1Msec(20);
	}
}

/*
*
* Main
* User Control
* Task
*
*/

// Runs the User Control Code Durring the User Control Portion of the Competition
task usercontrol()
{
	startTask(clawPID);
	startTask(updateClawUserControl);
	startTask(armUserControl);
	startTask(driveUserControl);

	while (true) sleep(9999);
}